-- Task 1: 
-- 1.Find the total number of employees
SELECT COUNT(*) AS total_employees FROM employees;
-- Interpretation: This query counts the total number of employees in the employees table.
-- 2:List all employees with their basic information
SELECT employeeNumber, lastName, firstName, extension, email, officeCode, reportsTo, jobTitle 
FROM employees;
-- Interpretation: This query retrieves basic information for all employees, including their employee number, last name, first name, extension, email, office code, manager's employee number, and job title.
-- 3: Count the number of employees holding each job title
SELECT jobTitle, COUNT(*) AS number_of_employees 
FROM employees 
GROUP BY jobTitle;
-- Interpretation: This query counts the number of employees for each job title, providing insights into the distribution of job roles within the organization.
-- 4: Find the employees who don't have a manager (reportsTo is NULL)
SELECT employeeNumber, lastName, firstName, jobTitle 
FROM employees 
WHERE reportsTo IS NULL;
-- Interpretation: This query identifies employees who do not report to anyone, which typically includes top-level managers or executives.

-- 5: Calculate total sales generated by each sales representative
SELECT  c.salesRepEmployeeNumber, SUM(od.quantityOrdered * od.priceEach) AS totalSales
FROM customers c
JOIN orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY c.salesRepEmployeeNumber;
-- Interpretation: This query calculates the total sales amount generated by each sales representative by summing 
-- the sales amounts from their respective customers' orders.

-- Task 6: Find the most profitable sales representative based on total sales
SELECT c.salesRepEmployeeNumber, SUM(od.quantityOrdered * od.priceEach) AS totalSales
FROM customers c
JOIN  orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
JOIN employees e ON c.salesRepEmployeeNumber = e.employeeNumber
GROUP BY salesRepEmployeeNumber
ORDER BY totalSales DESC
LIMIT 3;
-- Interpretation: This query identifies the most profitable sales representative by calculating total sales and sorting the results in descending order, then selecting the top record.

-- Task 7: Find the names of all employees who have sold more than the average sales amount for their office
WITH SalesPerRep AS ( 
    SELECT e.employeeNumber, e.firstName, e.lastName, e.officeCode, sUM(od.quantityOrdered * od.priceEach) AS totalSales
    FROM customers c
    JOIN orders o ON c.customerNumber = o.customerNumber
    JOIN orderdetails od ON o.orderNumber = od.orderNumber
    JOIN employees e ON c.salesRepEmployeeNumber = e.employeeNumber
    GROUP BY e.employeeNumber, e.firstName, e.lastName, e.officeCode ),
AverageSalesPerOffice AS (
    SELECT officeCode, AVG(totalSales) AS avgSales 
    FROM salesPerRep 
    GROUP BY officeCode )
SELECT e.firstName, e.lastName, s.totalSales, a.avgSales, o.city AS officeCity 
    FROM SalesPerRep s
JOIN AverageSalesPerOffice a ON s.officeCode = a.officeCode
JOIN employees e ON s.employeeNumber = e.employeeNumber
JOIN offices o ON s.officeCode = o.officeCode
WHERE s.totalSales > a.avgSales
order by a.avgsales desc
limit 10;


-- Task 2: Order Analysis

-- 1. Find the average order amount for each customer.

SELECT c.customerName, AVG(od.quantityOrdered * od.priceEach) AS avgOrderAmount
FROM customers c
JOIN orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY c.customerName;
-- Interpretation: Calculates the average amount spent per order for each customer.

-- 2. Find the number of orders placed in each month.
SELECT DATE_FORMAT(o.orderDate, '%Y-%m') AS orderMonth, COUNT(*) AS orderCount
FROM orders o
GROUP BY orderMonth;
-- Interpretation: Counts the number of orders placed in each month.

-- 3. Identify orders that are still pending shipment (status = 'Pending').

SELECT* FROM orders 
WHERE status = 'Pending';
-- Interpretation: Lists all orders that are still pending shipment.

-- 4. List orders along with customer details.

SELECT o.*, c.* FROM orders o
JOIN customers c ON o.customerNumber = c.customerNumber;
-- Interpretation: Retrieves all orders along with the corresponding customer details.

-- 5. Retrieve the most recent orders (based on order date).
SELECT* FROM orders 
ORDER BY orderDate DESC 
LIMIT 10;
-- Interpretation: Lists the 10 most recent orders based on the order date.

-- 6. Calculate total sales for each order.
SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalSales
FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber;
-- Interpretation: Computes the total sales amount for each order.

-- 7. Find the highest-value order based on total sales.

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalSales
FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber
ORDER BY totalSales DESC 
LIMIT 3;
-- Interpretation: Identifies the order with the highest total sales value.

-- 8. List all orders with their corresponding order details.

SELECT o.*, od.* FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber;
-- Interpretation: Retrieves all orders along with their respective order details.

-- 9. List the most frequently ordered products.

SELECT od.productCode, COUNT(*) AS orderCount
FROM orderdetails od
GROUP BY od.productCode
ORDER BY orderCount DESC;
-- Interpretation: Lists products ordered most frequently, sorted by order count.

-- 10. Calculate total revenue for each order.

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalRevenue
FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber;
-- Interpretation: Calculates the total revenue generated from each order.

-- 11. Identify the most profitable orders based on total revenue.

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalRevenue
FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber
ORDER BY totalRevenue DESC 
LIMIT 10;
-- Interpretation: Lists the top 10 most profitable orders based on total revenue.

-- 12. List all orders with detailed product information.

SELECT o.*, od.*, p.* FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
JOIN products p ON od.productCode = p.productCode;
-- Interpretation: Retrieves all orders along with detailed information about the products in each order.

-- 13. Identify orders with delayed shipping (shippedDate > requiredDate).

SELECT* FROM orders 
WHERE shippedDate > requiredDate;
-- Interpretation: Lists orders that were shipped later than their required date.

-- 14. Find the most popular product combinations within orders.

SELECT od1.productCode AS product1, od2.productCode AS product2, COUNT(*) AS combinationCount
FROM orderdetails od1
JOIN orderdetails od2 ON od1.orderNumber = od2.orderNumber AND od1.productCode < od2.productCode
GROUP BY product1, product2
ORDER BY combinationCount DESC;
-- Interpretation: Identifies the most frequently ordered product combinations.

-- 15. Calculate revenue for each order and identify the top 10 most profitable.

SELECT o.orderNumber, SUM(od.quantityOrdered * od.priceEach) AS totalRevenue
FROM orders o
JOIN orderdetails od ON o.orderNumber = od.orderNumber
GROUP BY o.orderNumber
ORDER BY totalRevenue DESC 
LIMIT 10;
-- Interpretation: Lists the top 10 most profitable orders based on total revenue.

-- 16. Create a trigger that automatically updates a customer's credit limit after a new order is placed, reducing it by the order total.


-- Interpretation: Automatically reduces a customer's credit limit by the total order amount whenever a new order is placed.

-- 17. Create a trigger that logs product quantity changes whenever an order detail is inserted or updated.

CREATE TABLE product_quantity_log (
    logID int AUTO_INCREMENT,
    orderNumber int,
    productCode varchar(15),
    oldQuantity int,
    newQuantity int,
    changeDate datetime DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (logID)
);
-- Interpretation: Logs changes in product quantities whenever an order detail is inserted or updated.